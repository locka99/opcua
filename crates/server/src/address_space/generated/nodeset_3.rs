// This file was autogenerated from Opc.Ua.NodeSet2.Part3.xml by tools/schema/gen_address_space.js
// DO NOT EDIT THIS FILE

#[allow(unused_imports)]
use std::{convert::TryFrom, str::FromStr};

#[allow(unused_imports)]
use crate::types::{service_types::Argument, *};

#[allow(unused_imports)]
use crate::address_space::{types::*, EventNotifier};

#[allow(unused_variables)]
pub fn populate_address_space(address_space: &mut AddressSpace) {
    add_object_1(address_space);
    add_object_2(address_space);
    add_object_3(address_space);
    add_object_4(address_space);
    add_object_5(address_space);
    add_object_6(address_space);
    add_object_7(address_space);
    add_object_8(address_space);
    add_object_9(address_space);
    add_object_10(address_space);
    add_object_11(address_space);
    add_object_12(address_space);
    add_datatype_13(address_space);
    add_datatype_14(address_space);
    add_datatype_15(address_space);
    add_datatype_16(address_space);
    add_datatype_17(address_space);
    add_datatype_18(address_space);
    add_datatype_19(address_space);
    add_datatype_20(address_space);
    add_datatype_21(address_space);
    add_datatype_22(address_space);
    add_datatype_23(address_space);
    add_datatype_24(address_space);
    add_datatype_25(address_space);
    add_datatype_26(address_space);
    add_datatype_27(address_space);
    add_datatype_28(address_space);
    add_datatype_29(address_space);
    add_datatype_30(address_space);
    add_datatype_31(address_space);
    add_datatype_32(address_space);
    add_datatype_33(address_space);
    add_datatype_34(address_space);
    add_datatype_35(address_space);
    add_datatype_36(address_space);
    add_datatype_37(address_space);
    add_datatype_38(address_space);
    add_datatype_39(address_space);
    add_datatype_40(address_space);
    add_datatype_41(address_space);
    add_datatype_42(address_space);
    add_datatype_43(address_space);
    add_datatype_44(address_space);
    add_datatype_45(address_space);
    add_datatype_46(address_space);
    add_datatype_47(address_space);
    add_datatype_48(address_space);
    add_datatype_49(address_space);
    add_datatype_50(address_space);
    add_datatype_51(address_space);
    add_datatype_52(address_space);
    add_datatype_53(address_space);
    add_datatype_54(address_space);
    add_datatype_55(address_space);
    add_datatype_56(address_space);
    add_datatype_57(address_space);
    add_datatype_58(address_space);
    add_datatype_59(address_space);
    add_referencetype_60(address_space);
    add_referencetype_61(address_space);
    add_referencetype_62(address_space);
    add_referencetype_63(address_space);
    add_referencetype_64(address_space);
    add_referencetype_65(address_space);
    add_referencetype_66(address_space);
    add_referencetype_67(address_space);
    add_referencetype_68(address_space);
    add_referencetype_69(address_space);
    add_referencetype_70(address_space);
    add_referencetype_71(address_space);
    add_referencetype_72(address_space);
    add_referencetype_73(address_space);
    add_referencetype_74(address_space);
    add_referencetype_75(address_space);
    add_referencetype_76(address_space);
    add_referencetype_77(address_space);
    add_variable_78(address_space);
    add_variable_79(address_space);
    add_variable_80(address_space);
    add_variable_81(address_space);
    add_variable_82(address_space);
    add_variable_83(address_space);
    add_variable_84(address_space);
    add_variable_85(address_space);
    add_variable_86(address_space);
    add_variable_87(address_space);
    add_variable_88(address_space);
    add_variable_89(address_space);
    add_variable_90(address_space);
    add_variable_91(address_space);
    add_variable_92(address_space);
    add_variable_93(address_space);
    add_variable_94(address_space);
    add_variable_95(address_space);
}

fn add_object_1(address_space: &mut AddressSpace) {
    // Object
    let name = "Default Binary";
    let node_id = NodeId::new(0, 3062);
    let mut node = Object::new(&node_id, name, name, EventNotifier::empty());
    node.set_description(LocalizedText::from(
        "The default binary encoding for a data type.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 58),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_object_2(address_space: &mut AddressSpace) {
    // Object
    let name = "Default XML";
    let node_id = NodeId::new(0, 3063);
    let mut node = Object::new(&node_id, name, name, EventNotifier::empty());
    node.set_description(LocalizedText::from(
        "The default XML encoding for a data type.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 58),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_object_3(address_space: &mut AddressSpace) {
    // Object
    let name = "Default XML";
    let node_id = NodeId::new(0, 297);
    let node = Object::new(&node_id, name, name, EventNotifier::empty());
    let _ = address_space.insert(
        node,
        Some(&[
            (
                &NodeId::new(0, 296),
                &ReferenceTypeId::HasEncoding,
                ReferenceDirection::Inverse,
            ),
            (
                &NodeId::new(0, 8285),
                &ReferenceTypeId::HasDescription,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 76),
                &ReferenceTypeId::HasTypeDefinition,
                ReferenceDirection::Forward,
            ),
        ]),
    );
}

fn add_object_4(address_space: &mut AddressSpace) {
    // Object
    let name = "Default XML";
    let node_id = NodeId::new(0, 7616);
    let node = Object::new(&node_id, name, name, EventNotifier::empty());
    let _ = address_space.insert(
        node,
        Some(&[
            (
                &NodeId::new(0, 7594),
                &ReferenceTypeId::HasEncoding,
                ReferenceDirection::Inverse,
            ),
            (
                &NodeId::new(0, 8291),
                &ReferenceTypeId::HasDescription,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 76),
                &ReferenceTypeId::HasTypeDefinition,
                ReferenceDirection::Forward,
            ),
        ]),
    );
}

fn add_object_5(address_space: &mut AddressSpace) {
    // Object
    let name = "Default XML";
    let node_id = NodeId::new(0, 12757);
    let node = Object::new(&node_id, name, name, EventNotifier::empty());
    let _ = address_space.insert(
        node,
        Some(&[
            (
                &NodeId::new(0, 12755),
                &ReferenceTypeId::HasEncoding,
                ReferenceDirection::Inverse,
            ),
            (
                &NodeId::new(0, 12759),
                &ReferenceTypeId::HasDescription,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 76),
                &ReferenceTypeId::HasTypeDefinition,
                ReferenceDirection::Forward,
            ),
        ]),
    );
}

fn add_object_6(address_space: &mut AddressSpace) {
    // Object
    let name = "Default XML";
    let node_id = NodeId::new(0, 12758);
    let node = Object::new(&node_id, name, name, EventNotifier::empty());
    let _ = address_space.insert(
        node,
        Some(&[
            (
                &NodeId::new(0, 12756),
                &ReferenceTypeId::HasEncoding,
                ReferenceDirection::Inverse,
            ),
            (
                &NodeId::new(0, 12762),
                &ReferenceTypeId::HasDescription,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 76),
                &ReferenceTypeId::HasTypeDefinition,
                ReferenceDirection::Forward,
            ),
        ]),
    );
}

fn add_object_7(address_space: &mut AddressSpace) {
    // Object
    let name = "Default XML";
    let node_id = NodeId::new(0, 8913);
    let node = Object::new(&node_id, name, name, EventNotifier::empty());
    let _ = address_space.insert(
        node,
        Some(&[
            (
                &NodeId::new(0, 8912),
                &ReferenceTypeId::HasEncoding,
                ReferenceDirection::Inverse,
            ),
            (
                &NodeId::new(0, 8918),
                &ReferenceTypeId::HasDescription,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 76),
                &ReferenceTypeId::HasTypeDefinition,
                ReferenceDirection::Forward,
            ),
        ]),
    );
}

fn add_object_8(address_space: &mut AddressSpace) {
    // Object
    let name = "Default Binary";
    let node_id = NodeId::new(0, 298);
    let node = Object::new(&node_id, name, name, EventNotifier::empty());
    let _ = address_space.insert(
        node,
        Some(&[
            (
                &NodeId::new(0, 296),
                &ReferenceTypeId::HasEncoding,
                ReferenceDirection::Inverse,
            ),
            (
                &NodeId::new(0, 7650),
                &ReferenceTypeId::HasDescription,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 76),
                &ReferenceTypeId::HasTypeDefinition,
                ReferenceDirection::Forward,
            ),
        ]),
    );
}

fn add_object_9(address_space: &mut AddressSpace) {
    // Object
    let name = "Default Binary";
    let node_id = NodeId::new(0, 8251);
    let node = Object::new(&node_id, name, name, EventNotifier::empty());
    let _ = address_space.insert(
        node,
        Some(&[
            (
                &NodeId::new(0, 7594),
                &ReferenceTypeId::HasEncoding,
                ReferenceDirection::Inverse,
            ),
            (
                &NodeId::new(0, 7656),
                &ReferenceTypeId::HasDescription,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 76),
                &ReferenceTypeId::HasTypeDefinition,
                ReferenceDirection::Forward,
            ),
        ]),
    );
}

fn add_object_10(address_space: &mut AddressSpace) {
    // Object
    let name = "Default Binary";
    let node_id = NodeId::new(0, 12765);
    let node = Object::new(&node_id, name, name, EventNotifier::empty());
    let _ = address_space.insert(
        node,
        Some(&[
            (
                &NodeId::new(0, 12755),
                &ReferenceTypeId::HasEncoding,
                ReferenceDirection::Inverse,
            ),
            (
                &NodeId::new(0, 12767),
                &ReferenceTypeId::HasDescription,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 76),
                &ReferenceTypeId::HasTypeDefinition,
                ReferenceDirection::Forward,
            ),
        ]),
    );
}

fn add_object_11(address_space: &mut AddressSpace) {
    // Object
    let name = "Default Binary";
    let node_id = NodeId::new(0, 12766);
    let node = Object::new(&node_id, name, name, EventNotifier::empty());
    let _ = address_space.insert(
        node,
        Some(&[
            (
                &NodeId::new(0, 12756),
                &ReferenceTypeId::HasEncoding,
                ReferenceDirection::Inverse,
            ),
            (
                &NodeId::new(0, 12770),
                &ReferenceTypeId::HasDescription,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 76),
                &ReferenceTypeId::HasTypeDefinition,
                ReferenceDirection::Forward,
            ),
        ]),
    );
}

fn add_object_12(address_space: &mut AddressSpace) {
    // Object
    let name = "Default Binary";
    let node_id = NodeId::new(0, 8917);
    let node = Object::new(&node_id, name, name, EventNotifier::empty());
    let _ = address_space.insert(
        node,
        Some(&[
            (
                &NodeId::new(0, 8912),
                &ReferenceTypeId::HasEncoding,
                ReferenceDirection::Inverse,
            ),
            (
                &NodeId::new(0, 8914),
                &ReferenceTypeId::HasDescription,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 76),
                &ReferenceTypeId::HasTypeDefinition,
                ReferenceDirection::Forward,
            ),
        ]),
    );
}

fn add_datatype_13(address_space: &mut AddressSpace) {
    // DataType
    let name = "BaseDataType";
    let node_id = NodeId::new(0, 24);
    let mut node = DataType::new(&node_id, name, name, true);
    node.set_description(LocalizedText::from(
        "Describes a value that can have any valid DataType.",
    ));
    let _ = address_space.insert::<DataType, ReferenceTypeId>(node, None);
}

fn add_datatype_14(address_space: &mut AddressSpace) {
    // DataType
    let name = "Number";
    let node_id = NodeId::new(0, 26);
    let mut node = DataType::new(&node_id, name, name, true);
    node.set_description(LocalizedText::from(
        "Describes a value that can have any numeric DataType.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 24),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_15(address_space: &mut AddressSpace) {
    // DataType
    let name = "Integer";
    let node_id = NodeId::new(0, 27);
    let mut node = DataType::new(&node_id, name, name, true);
    node.set_description(LocalizedText::from(
        "Describes a value that can have any integer DataType.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 26),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_16(address_space: &mut AddressSpace) {
    // DataType
    let name = "UInteger";
    let node_id = NodeId::new(0, 28);
    let mut node = DataType::new(&node_id, name, name, true);
    node.set_description(LocalizedText::from(
        "Describes a value that can have any unsigned integer DataType.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 26),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_17(address_space: &mut AddressSpace) {
    // DataType
    let name = "Enumeration";
    let node_id = NodeId::new(0, 29);
    let mut node = DataType::new(&node_id, name, name, true);
    node.set_description(LocalizedText::from(
        "Describes a value that is an enumerated DataType.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 24),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_18(address_space: &mut AddressSpace) {
    // DataType
    let name = "Boolean";
    let node_id = NodeId::new(0, 1);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is either TRUE or FALSE.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 24),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_19(address_space: &mut AddressSpace) {
    // DataType
    let name = "SByte";
    let node_id = NodeId::new(0, 2);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is an integer between -128 and 127.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 27),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_20(address_space: &mut AddressSpace) {
    // DataType
    let name = "Byte";
    let node_id = NodeId::new(0, 3);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is an integer between 0 and 255.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 28),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_21(address_space: &mut AddressSpace) {
    // DataType
    let name = "Int16";
    let node_id = NodeId::new(0, 4);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is an integer between −32,768 and 32,767.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 27),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_22(address_space: &mut AddressSpace) {
    // DataType
    let name = "UInt16";
    let node_id = NodeId::new(0, 5);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is an integer between 0 and 65535.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 28),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_23(address_space: &mut AddressSpace) {
    // DataType
    let name = "Int32";
    let node_id = NodeId::new(0, 6);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is an integer between −2,147,483,648  and 2,147,483,647.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 27),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_24(address_space: &mut AddressSpace) {
    // DataType
    let name = "UInt32";
    let node_id = NodeId::new(0, 7);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is an integer between 0 and 4,294,967,295.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 28),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_25(address_space: &mut AddressSpace) {
    // DataType
    let name = "Int64";
    let node_id = NodeId::new(0, 8);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from("Describes a value that is an integer between −9,223,372,036,854,775,808 and 9,223,372,036,854,775,807."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 27),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_26(address_space: &mut AddressSpace) {
    // DataType
    let name = "UInt64";
    let node_id = NodeId::new(0, 9);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is an integer between 0 and 18,446,744,073,709,551,615.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 28),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_27(address_space: &mut AddressSpace) {
    // DataType
    let name = "Float";
    let node_id = NodeId::new(0, 10);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is an IEEE 754-1985 single precision floating point number.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 26),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_28(address_space: &mut AddressSpace) {
    // DataType
    let name = "Double";
    let node_id = NodeId::new(0, 11);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is an IEEE 754-1985 double precision floating point number.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 26),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_29(address_space: &mut AddressSpace) {
    // DataType
    let name = "String";
    let node_id = NodeId::new(0, 12);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is a sequence of printable Unicode characters.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 24),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_30(address_space: &mut AddressSpace) {
    // DataType
    let name = "DateTime";
    let node_id = NodeId::new(0, 13);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is a Gregorian calender date and time.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 24),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_31(address_space: &mut AddressSpace) {
    // DataType
    let name = "Guid";
    let node_id = NodeId::new(0, 14);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is a 128-bit globally unique identifier.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 24),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_32(address_space: &mut AddressSpace) {
    // DataType
    let name = "ByteString";
    let node_id = NodeId::new(0, 15);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is a sequence of bytes.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 24),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_33(address_space: &mut AddressSpace) {
    // DataType
    let name = "XmlElement";
    let node_id = NodeId::new(0, 16);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is an XML element.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 24),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_34(address_space: &mut AddressSpace) {
    // DataType
    let name = "NodeId";
    let node_id = NodeId::new(0, 17);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is an identifier for a node within a Server address space.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 24),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_35(address_space: &mut AddressSpace) {
    // DataType
    let name = "QualifiedName";
    let node_id = NodeId::new(0, 20);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is a name qualified by a namespace.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 24),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_36(address_space: &mut AddressSpace) {
    // DataType
    let name = "LocalizedText";
    let node_id = NodeId::new(0, 21);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is human readable Unicode text with a locale identifier.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 24),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_37(address_space: &mut AddressSpace) {
    // DataType
    let name = "Structure";
    let node_id = NodeId::new(0, 22);
    let mut node = DataType::new(&node_id, name, name, true);
    node.set_description(LocalizedText::from("Describes a value that is any type of structure that can be described with a data encoding."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 24),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_38(address_space: &mut AddressSpace) {
    // DataType
    let name = "Image";
    let node_id = NodeId::new(0, 30);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "Describes a value that is an image encoded as a string of bytes.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 15),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_39(address_space: &mut AddressSpace) {
    // DataType
    let name = "Decimal128";
    let node_id = NodeId::new(0, 121);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from("Describes a 128-bit decimal value."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 26),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_40(address_space: &mut AddressSpace) {
    // DataType
    let name = "NamingRuleType";
    let node_id = NodeId::new(0, 120);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from("Describes a value that specifies the significance of the BrowseName for an instance declaration."));
    let _ = address_space.insert(
        node,
        Some(&[
            (
                &NodeId::new(0, 12169),
                &ReferenceTypeId::HasProperty,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 29),
                &ReferenceTypeId::HasSubtype,
                ReferenceDirection::Inverse,
            ),
        ]),
    );
}

fn add_datatype_41(address_space: &mut AddressSpace) {
    // DataType
    let name = "ImageBMP";
    let node_id = NodeId::new(0, 2000);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from("An image encoded in BMP format."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 30),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_42(address_space: &mut AddressSpace) {
    // DataType
    let name = "ImageGIF";
    let node_id = NodeId::new(0, 2001);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from("An image encoded in GIF format."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 30),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_43(address_space: &mut AddressSpace) {
    // DataType
    let name = "ImageJPG";
    let node_id = NodeId::new(0, 2002);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from("An image encoded in JPEG format."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 30),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_44(address_space: &mut AddressSpace) {
    // DataType
    let name = "ImagePNG";
    let node_id = NodeId::new(0, 2003);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from("An image encoded in PNG format."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 30),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_45(address_space: &mut AddressSpace) {
    // DataType
    let name = "IdType";
    let node_id = NodeId::new(0, 256);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "The type of identifier used in a node id.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[
            (
                &NodeId::new(0, 7591),
                &ReferenceTypeId::HasProperty,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 29),
                &ReferenceTypeId::HasSubtype,
                ReferenceDirection::Inverse,
            ),
        ]),
    );
}

fn add_datatype_46(address_space: &mut AddressSpace) {
    // DataType
    let name = "NodeClass";
    let node_id = NodeId::new(0, 257);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "A mask specifying the class of the node.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[
            (
                &NodeId::new(0, 11878),
                &ReferenceTypeId::HasProperty,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 29),
                &ReferenceTypeId::HasSubtype,
                ReferenceDirection::Inverse,
            ),
        ]),
    );
}

fn add_datatype_47(address_space: &mut AddressSpace) {
    // DataType
    let name = "Argument";
    let node_id = NodeId::new(0, 296);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from("An argument for a method."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 22),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_48(address_space: &mut AddressSpace) {
    // DataType
    let name = "EnumValueType";
    let node_id = NodeId::new(0, 7594);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "A mapping between a value of an enumerated type and a name and description.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 22),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_49(address_space: &mut AddressSpace) {
    // DataType
    let name = "OptionSet";
    let node_id = NodeId::new(0, 12755);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from("This abstract Structured DataType is the base DataType for all DataTypes representing a bit mask."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 22),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_50(address_space: &mut AddressSpace) {
    // DataType
    let name = "Union";
    let node_id = NodeId::new(0, 12756);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "This abstract DataType is the base DataType for all union DataTypes.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 22),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_51(address_space: &mut AddressSpace) {
    // DataType
    let name = "NormalizedString";
    let node_id = NodeId::new(0, 12877);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "A string normalized based on the rules in the unicode specification.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 12),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_52(address_space: &mut AddressSpace) {
    // DataType
    let name = "DecimalString";
    let node_id = NodeId::new(0, 12878);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from("An arbitraty numeric value."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 12),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_53(address_space: &mut AddressSpace) {
    // DataType
    let name = "DurationString";
    let node_id = NodeId::new(0, 12879);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "A period of time formatted as defined in ISO 8601-2000.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 12),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_54(address_space: &mut AddressSpace) {
    // DataType
    let name = "TimeString";
    let node_id = NodeId::new(0, 12880);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "A time formatted as defined in ISO 8601-2000.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 12),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_55(address_space: &mut AddressSpace) {
    // DataType
    let name = "DateString";
    let node_id = NodeId::new(0, 12881);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "A date formatted as defined in ISO 8601-2000.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 12),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_56(address_space: &mut AddressSpace) {
    // DataType
    let name = "Duration";
    let node_id = NodeId::new(0, 290);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "A period of time measured in milliseconds.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 11),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_57(address_space: &mut AddressSpace) {
    // DataType
    let name = "UtcTime";
    let node_id = NodeId::new(0, 294);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from(
        "A date/time value specified in Universal Coordinated Time (UTC).",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 13),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_58(address_space: &mut AddressSpace) {
    // DataType
    let name = "LocaleId";
    let node_id = NodeId::new(0, 295);
    let mut node = DataType::new(&node_id, name, name, false);
    node.set_description(LocalizedText::from("An identifier for a user locale."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 12),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_datatype_59(address_space: &mut AddressSpace) {
    // DataType
    let name = "TimeZoneDataType";
    let node_id = NodeId::new(0, 8912);
    let node = DataType::new(&node_id, name, name, false);
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 22),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_60(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "References";
    let node_id = NodeId::new(0, 31);
    let mut node = ReferenceType::new(&node_id, name, name, None, true, true);
    node.set_description(LocalizedText::from(
        "The abstract base type for all references.",
    ));
    let _ = address_space.insert::<ReferenceType, ReferenceTypeId>(node, None);
}

fn add_referencetype_61(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "NonHierarchicalReferences";
    let node_id = NodeId::new(0, 32);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "NonHierarchicalReferences")),
        false,
        true,
    );
    node.set_description(LocalizedText::from(
        "The abstract base type for all non-hierarchical references.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 31),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_62(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "HierarchicalReferences";
    let node_id = NodeId::new(0, 33);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "HierarchicalReferences")),
        false,
        true,
    );
    node.set_description(LocalizedText::from(
        "The abstract base type for all hierarchical references.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 31),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_63(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "HasChild";
    let node_id = NodeId::new(0, 34);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "ChildOf")),
        false,
        false,
    );
    node.set_description(LocalizedText::from(
        "The abstract base type for all non-looping hierarchical references.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 33),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_64(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "Organizes";
    let node_id = NodeId::new(0, 35);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "OrganizedBy")),
        false,
        false,
    );
    node.set_description(LocalizedText::from(
        "The type for hierarchical references that are used to organize nodes.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 33),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_65(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "HasEventSource";
    let node_id = NodeId::new(0, 36);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "EventSourceOf")),
        false,
        false,
    );
    node.set_description(LocalizedText::from(
        "The type for non-looping hierarchical references that are used to organize event sources.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 33),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_66(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "HasModellingRule";
    let node_id = NodeId::new(0, 37);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "ModellingRuleOf")),
        false,
        false,
    );
    node.set_description(LocalizedText::from(
        "The type for references from instance declarations to modelling rule nodes.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 32),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_67(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "HasEncoding";
    let node_id = NodeId::new(0, 38);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "EncodingOf")),
        false,
        false,
    );
    node.set_description(LocalizedText::from(
        "The type for references from data type nodes to to data type encoding nodes.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 32),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_68(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "HasDescription";
    let node_id = NodeId::new(0, 39);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "DescriptionOf")),
        false,
        false,
    );
    node.set_description(LocalizedText::from(
        "The type for references from data type encoding nodes to data type description nodes.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 32),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_69(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "HasTypeDefinition";
    let node_id = NodeId::new(0, 40);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "TypeDefinitionOf")),
        false,
        false,
    );
    node.set_description(LocalizedText::from(
        "The type for references from a instance node its type defintion node.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 32),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_70(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "GeneratesEvent";
    let node_id = NodeId::new(0, 41);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "GeneratesEvent")),
        false,
        false,
    );
    node.set_description(LocalizedText::from(
        "The type for references from a node to an event type that is raised by node.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 32),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_71(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "AlwaysGeneratesEvent";
    let node_id = NodeId::new(0, 3065);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "AlwaysGeneratesEvent")),
        false,
        false,
    );
    node.set_description(LocalizedText::from(
        "The type for references from a node to an event type that is always raised by node.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 41),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_72(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "Aggregates";
    let node_id = NodeId::new(0, 44);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "AggregatedBy")),
        false,
        false,
    );
    node.set_description(LocalizedText::from("The type for non-looping hierarchical references that are used to aggregate nodes into complex types."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 34),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_73(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "HasSubtype";
    let node_id = NodeId::new(0, 45);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "SubtypeOf")),
        false,
        false,
    );
    node.set_description(LocalizedText::from(
        "The type for non-looping hierarchical references that are used to define sub types.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 34),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_74(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "HasProperty";
    let node_id = NodeId::new(0, 46);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "PropertyOf")),
        false,
        false,
    );
    node.set_description(LocalizedText::from(
        "The type for non-looping hierarchical reference from a node to its property.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 44),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_75(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "HasComponent";
    let node_id = NodeId::new(0, 47);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "ComponentOf")),
        false,
        false,
    );
    node.set_description(LocalizedText::from(
        "The type for non-looping hierarchical reference from a node to its component.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 44),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_76(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "HasNotifier";
    let node_id = NodeId::new(0, 48);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "NotifierOf")),
        false,
        false,
    );
    node.set_description(LocalizedText::from("The type for non-looping hierarchical references that are used to indicate how events propagate from node to node."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 36),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_referencetype_77(address_space: &mut AddressSpace) {
    // ReferenceType
    let name = "HasOrderedComponent";
    let node_id = NodeId::new(0, 49);
    let mut node = ReferenceType::new(
        &node_id,
        name,
        name,
        Some(LocalizedText::new("", "OrderedComponentOf")),
        false,
        false,
    );
    node.set_description(LocalizedText::from("The type for non-looping hierarchical reference from a node to its component when the order of references matters."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 47),
            &ReferenceTypeId::HasSubtype,
            ReferenceDirection::Inverse,
        )]),
    );
}

fn add_variable_78(address_space: &mut AddressSpace) {
    // Variable
    let name = "EnumValues";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 12169);
    let node = Variable::new_data_value(
        &node_id,
        name,
        name,
        DataTypeId::try_from(7594u32).unwrap(),
        value,
    );
    let _ = address_space.insert(
        node,
        Some(&[
            (
                &NodeId::new(0, 68),
                &ReferenceTypeId::HasTypeDefinition,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 78),
                &ReferenceTypeId::HasModellingRule,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 120),
                &ReferenceTypeId::HasProperty,
                ReferenceDirection::Inverse,
            ),
        ]),
    );
}

fn add_variable_79(address_space: &mut AddressSpace) {
    // Variable
    let name = "NodeVersion";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 3068);
    let mut node = Variable::new_data_value(&node_id, name, name, DataTypeId::String, value);
    node.set_description(LocalizedText::from("The version number of the node (used to indicate changes to references of the owning node)."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 68),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_variable_80(address_space: &mut AddressSpace) {
    // Variable
    let name = "ViewVersion";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 12170);
    let mut node = Variable::new_data_value(&node_id, name, name, DataTypeId::UInt32, value);
    node.set_description(LocalizedText::from("The version number of the view."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 68),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_variable_81(address_space: &mut AddressSpace) {
    // Variable
    let name = "Icon";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 3067);
    let mut node = Variable::new_data_value(
        &node_id,
        name,
        name,
        DataTypeId::try_from(30u32).unwrap(),
        value,
    );
    node.set_description(LocalizedText::from(
        "A small image representing the object.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 68),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_variable_82(address_space: &mut AddressSpace) {
    // Variable
    let name = "LocalTime";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 3069);
    let mut node = Variable::new_data_value(
        &node_id,
        name,
        name,
        DataTypeId::try_from(8912u32).unwrap(),
        value,
    );
    node.set_description(LocalizedText::from(
        "The local time where the owning variable value was collected.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 68),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_variable_83(address_space: &mut AddressSpace) {
    // Variable
    let name = "AllowNulls";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 3070);
    let mut node = Variable::new_data_value(&node_id, name, name, DataTypeId::Boolean, value);
    node.set_description(LocalizedText::from(
        "Whether the value of the owning variable is allowed to be null.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 68),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_variable_84(address_space: &mut AddressSpace) {
    // Variable
    let name = "ValueAsText";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 11433);
    let mut node = Variable::new_data_value(&node_id, name, name, DataTypeId::LocalizedText, value);
    node.set_description(LocalizedText::from("The string representation of the current value for a variable with an enumerated data type."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 68),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_variable_85(address_space: &mut AddressSpace) {
    // Variable
    let name = "MaxStringLength";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 11498);
    let mut node = Variable::new_data_value(&node_id, name, name, DataTypeId::UInt32, value);
    node.set_description(LocalizedText::from(
        "The maximum length for a string that can be stored in the owning variable.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 68),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_variable_86(address_space: &mut AddressSpace) {
    // Variable
    let name = "MaxByteStringLength";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 12908);
    let mut node = Variable::new_data_value(&node_id, name, name, DataTypeId::UInt32, value);
    node.set_description(LocalizedText::from(
        "The maximum length for a byte string that can be stored in the owning variable.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 68),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_variable_87(address_space: &mut AddressSpace) {
    // Variable
    let name = "MaxArrayLength";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 11512);
    let mut node = Variable::new_data_value(&node_id, name, name, DataTypeId::UInt32, value);
    node.set_description(LocalizedText::from(
        "The maximum length for an array that can be stored in the owning variable.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 68),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_variable_88(address_space: &mut AddressSpace) {
    // Variable
    let name = "EngineeringUnits";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 11513);
    let mut node = Variable::new_data_value(
        &node_id,
        name,
        name,
        DataTypeId::try_from(887u32).unwrap(),
        value,
    );
    node.set_description(LocalizedText::from(
        "The engineering units for the value of the owning variable.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 68),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_variable_89(address_space: &mut AddressSpace) {
    // Variable
    let name = "EnumStrings";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 11432);
    let mut node = Variable::new_data_value(&node_id, name, name, DataTypeId::LocalizedText, value);
    node.set_description(LocalizedText::from("The human readable strings associated with the values of an enumerated value (when values are sequential)."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 68),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_variable_90(address_space: &mut AddressSpace) {
    // Variable
    let name = "EnumValues";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 3071);
    let mut node = Variable::new_data_value(
        &node_id,
        name,
        name,
        DataTypeId::try_from(7594u32).unwrap(),
        value,
    );
    node.set_description(LocalizedText::from("The human readable strings associated with the values of an enumerated value (when values have no sequence)."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 68),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_variable_91(address_space: &mut AddressSpace) {
    // Variable
    let name = "OptionSetValues";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 12745);
    let mut node = Variable::new_data_value(&node_id, name, name, DataTypeId::LocalizedText, value);
    node.set_description(LocalizedText::from(
        "Contains the human-readable representation for each bit of the bit mask.",
    ));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 68),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_variable_92(address_space: &mut AddressSpace) {
    // Variable
    let name = "InputArguments";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 3072);
    let mut node = Variable::new_data_value(
        &node_id,
        name,
        name,
        DataTypeId::try_from(296u32).unwrap(),
        value,
    );
    node.set_description(LocalizedText::from("The input arguments for a method."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 68),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_variable_93(address_space: &mut AddressSpace) {
    // Variable
    let name = "OutputArguments";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 3073);
    let mut node = Variable::new_data_value(
        &node_id,
        name,
        name,
        DataTypeId::try_from(296u32).unwrap(),
        value,
    );
    node.set_description(LocalizedText::from("The output arguments for a method."));
    let _ = address_space.insert(
        node,
        Some(&[(
            &NodeId::new(0, 68),
            &ReferenceTypeId::HasTypeDefinition,
            ReferenceDirection::Forward,
        )]),
    );
}

fn add_variable_94(address_space: &mut AddressSpace) {
    // Variable
    let name = "EnumStrings";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 7591);
    let node = Variable::new_data_value(&node_id, name, name, DataTypeId::LocalizedText, value);
    let _ = address_space.insert(
        node,
        Some(&[
            (
                &NodeId::new(0, 68),
                &ReferenceTypeId::HasTypeDefinition,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 78),
                &ReferenceTypeId::HasModellingRule,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 256),
                &ReferenceTypeId::HasProperty,
                ReferenceDirection::Inverse,
            ),
        ]),
    );
}

fn add_variable_95(address_space: &mut AddressSpace) {
    // Variable
    let name = "EnumValues";
    let value = Variant::Empty;
    let node_id = NodeId::new(0, 11878);
    let node = Variable::new_data_value(
        &node_id,
        name,
        name,
        DataTypeId::try_from(7594u32).unwrap(),
        value,
    );
    let _ = address_space.insert(
        node,
        Some(&[
            (
                &NodeId::new(0, 68),
                &ReferenceTypeId::HasTypeDefinition,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 78),
                &ReferenceTypeId::HasModellingRule,
                ReferenceDirection::Forward,
            ),
            (
                &NodeId::new(0, 257),
                &ReferenceTypeId::HasProperty,
                ReferenceDirection::Inverse,
            ),
        ]),
    );
}
